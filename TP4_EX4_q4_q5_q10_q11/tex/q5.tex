\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{hyperref}

\geometry{margin=2.2cm}
\graphicspath{{figs/q5/}}
\sisetup{locale=FR}

\title{TP4 -- Exercice 4 (Q5)\\\small Evaluation de performances (Cortex A15) en fonction de la taille des caches L1}
\author{\small Nom: \underline{\hspace{5cm}} \qquad Groupe: \underline{\hspace{2cm}}}
\date{\small Ann\'ee 2026}

\begin{document}
\maketitle

\section{Objectif}
Le but de la question Q5 est d'\'evaluer les performances d'un coeur \emph{type Cortex A15} (mod\`ele RISCV dans gem5 en \emph{out-of-order}) en faisant varier simultan\'ement la taille des caches L1 (instructions et donn\'ees) de \SI{2}{kB} \`a \SI{32}{kB}, avec un cache L2 fix\'e \`a \SI{512}{kB}. On compare les r\'esultats sur deux applications MiBench : \textbf{Dijkstra} et \textbf{Blowfish}.

\section{Configuration et m\'ethodologie}
\subsection{Param\`etres processeur / caches}
Pour le coeur ``A15'' (Tableau 12 du sujet), on utilise :
\begin{itemize}
\item CPU : \texttt{DerivO3CPU} (gem5 classic), mode \texttt{timing}.
\item Pr\'ediction : \texttt{TournamentBP} avec \texttt{BTBEntries=256}.
\item Largeurs : decode=4, issue=8, commit=4 ; ROB=16 ; LQ=16 ; SQ=16 ; fetchQueue=15.
\item Lignes de cache : \SI{64}{B} (et \texttt{fetchBufferSize} mis \`a \SI{64}{B}).
\item L2 : \SI{512}{kB}, assoc=16, bloc=\SI{64}{B} (fixe).
\item L1I et L1D : assoc=2, bloc=\SI{64}{B}, taille variable : \{2,4,8,16,32\}\,kB.
\end{itemize}

\subsection{Benchmarks et entr\'ees}
\begin{itemize}
\item \textbf{Dijkstra}: ex\'ecution de \texttt{dijkstra\_small} avec \texttt{input.dat} (MiBench).
\item \textbf{Blowfish}: on a mesur\'e \texttt{bf} en chiffrement (\texttt{e}) + d\'echiffrement (\texttt{d}) sur \texttt{input\_small.asc}. Les courbes ``Blowfish'' correspondent \`a l'agr\'egation \emph{enc+dec} (somme des cycles et des instructions).
\end{itemize}

\subsection{Commande gem5 (param\`etres d'ex\'ecution)}
Les simulations ont \`et\'e lanc\'ees via un script pour balayer les tailles de L1.
\begin{verbatim}
PYTHONUTF8=1 /opt/gem5/build/RISCV/gem5.opt -r -d <outdir> \
  gem5/se_A15_q5.py --l1 <2kB|4kB|8kB|16kB|32kB> \
  --maxinsts 0 \
  --cmd <binary> --options <args>
\end{verbatim}
Le script utilis\'e est \texttt{scripts/run\_q5\_a15.sh}. Les r\'esultats bruts sont dans \texttt{m5out/q5/A15\_nolimit\_20260210/}.

\paragraph{Remarque (comparaison juste).}
Pour comparer les tailles de cache de mani\`ere \`equitable, les ex\'ecutions sont faites \emph{jusqu'\`a la fin du programme} (\texttt{--maxinsts 0}).

\section{R\'esultats}
\subsection{Synth\`ese (meilleure configuration)}
La table suivante r\'esume la configuration L1 donnant les meilleurs r\'esultats (crit\`ere : cycles minimaux).

\begin{center}
\input{tables/q5_a15_summary.tex}
\end{center}

\subsection{Dijkstra}
\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_dijkstra_cycles.png}
\caption{Dijkstra (A15) : cycles en fonction de la taille L1.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_dijkstra_ipc.png}
\caption{Dijkstra (A15) : IPC en fonction de la taille L1.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_dijkstra_dl1_miss.png}
\caption{Dijkstra (A15) : miss rate DL1.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_dijkstra_il1_miss.png}
\caption{Dijkstra (A15) : miss rate IL1.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_dijkstra_bp_mispred.png}
\caption{Dijkstra (A15) : taux de mauvaise pr\'ediction (branches conditionnelles) vs taille L1.}
\end{figure}

\paragraph{Analyse (Dijkstra).}
Quand on augmente L1, les miss rates (surtout DL1) diminuent et les cycles baissent, ce qui am\'eliore l'IPC. Comme pour Q4, le taux de mauvaise pr\'ediction varie peu avec la taille de L1 : les gains sont domin\'es par la hi\'erarchie m\'emoire plut\^ot que par la qualit\'e de pr\'ediction.

\subsection{Blowfish (enc+dec)}
\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_blowfish_cycles.png}
\caption{Blowfish (A15) : cycles (chiffrement+d\'echiffrement) vs L1.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_blowfish_ipc.png}
\caption{Blowfish (A15) : IPC (enc+dec) vs L1.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_blowfish_dl1_miss.png}
\caption{Blowfish (A15) : miss rate DL1 (enc+dec).}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_blowfish_il1_miss.png}
\caption{Blowfish (A15) : miss rate IL1 (enc+dec).}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\linewidth]{a15_blowfish_bp_mispred.png}
\caption{Blowfish (A15) : taux de mauvaise pr\'ediction (branches conditionnelles) vs taille L1.}
\end{figure}

\paragraph{Analyse (Blowfish).}
Blowfish est tr\`es \emph{compute-bound} dans nos r\'esultats (miss rates faibles), donc l'IPC varie moins fortement avec L1 que pour Dijkstra. Une taille L1 suffisante permet d'\'eviter des misses r\'esiduelles, puis les gains saturent.

\section{Conclusion}
Pour le coeur A15, augmenter L1 am\'eliore globalement les performances au d\'ebut (moins de misses, plus d'IPC), puis les gains se stabilisent. La ``meilleure'' taille est celle qui minimise les cycles pour l'application consid\'er\'ee.

\end{document}
